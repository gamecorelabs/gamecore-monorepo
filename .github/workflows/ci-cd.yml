# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  GITHUB_REGISTRY: ghcr.io
  DOCKER_REGISTRY: docker.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ë³€ê²½ëœ íŒŒì¼ ê°ì§€
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.changes.outputs.frontend }}
      auth-api: ${{ steps.changes.outputs.auth-api }}
      admin-api: ${{ steps.changes.outputs.admin-api }}
      data-api: ${{ steps.changes.outputs.data-api }}
      core: ${{ steps.changes.outputs.core }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            frontend:
              - 'apps/frontend/**'
            auth-api:
              - 'apps/auth-api/**'
              - 'packages/core/**'
            admin-api:
              - 'apps/admin-api/**'
              - 'packages/core/**'
            data-api:
              - 'apps/data-api/**'
              - 'packages/core/**'

  # Frontend ë¹Œë“œ
  build-frontend:
    needs: detect-changes
    if: needs.detect-changes.outputs.frontend == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: "apps/frontend/package-lock.json"

      - name: Create environment file
        working-directory: apps/frontend
        run: |
          cat > .env.production << EOF
          NODE_ENV=production
          NEXT_PUBLIC_DATA_API_URL=https://data-api.gamecore.co.kr
          NEXT_PUBLIC_ADMIN_API_URL=https://admin-api.gamecore.co.kr
          NEXT_PUBLIC_AUTH_API_URL=https://auth-api.gamecore.co.kr
          INTERNAL_DATA_API_URL=http://data-api:3000
          INTERNAL_ADMIN_API_URL=http://admin-api:3000
          INTERNAL_AUTH_API_URL=http://auth-api:3000
          NEXT_PUBLIC_S3_URL=https://${{ secrets.AWS_S3_BUCKET_NAME }}.s3.${{ secrets.AWS_REGION }}.amazonaws.com
          NEXT_PUBLIC_DOMAIN=gamecore.co.kr
          PORT=3000
          EOF

      - name: Install dependencies
        working-directory: apps/frontend
        run: npm ci

      - name: Build application
        working-directory: apps/frontend
        run: npm run build

      - name: Run tests
        working-directory: apps/frontend
        run: npm run test --if-present

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GITHUB_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GH_TOKEN }}

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.GITHUB_REGISTRY }}/${{ env.IMAGE_NAME }}/frontend
            ${{ env.DOCKER_REGISTRY }}/${{ secrets.DOCKER_HUB_USERNAME }}/gamecore-frontend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: apps/frontend
          file: apps/frontend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64

  # Auth API ë¹Œë“œ
  build-auth-api:
    needs: [detect-changes]
    if: needs.detect-changes.outputs.auth-api == 'true' && !failure()
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: "apps/auth-api/package-lock.json"

      - name: Create .npmrc
        working-directory: apps/auth-api
        run: |
          cat > .npmrc << EOF
          @gamecorelabs:registry=https://npm.pkg.github.com
          //npm.pkg.github.com/:_authToken=${{ secrets.GH_TOKEN }}
          EOF

      - name: Create environment file
        working-directory: apps/auth-api
        run: |
          cat > .env.production << EOF
          NODE_ENV=production
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_DATABASE=${{ secrets.DB_DATABASE }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET_NAME=${{ secrets.AWS_S3_BUCKET_NAME }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          HASH_ROUNDS=${{ secrets.HASH_ROUNDS }}
          PORT=3000
          CORS_ORIGIN=https://gamecore.co.kr,https://*.gamecore.co.kr
          EOF

      - name: Install latest @gamecorelabs/nestjs-core
        working-directory: apps/auth-api
        run: npm install @gamecorelabs/nestjs-core@latest

      - name: Install dependencies
        working-directory: apps/auth-api
        run: npm ci

      - name: Build application
        working-directory: apps/auth-api
        run: npm run build:prod

      # - name: Run tests
      #   working-directory: apps/auth-api
      #   run: npm run test --if-present

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GITHUB_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GH_TOKEN }}

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.GITHUB_REGISTRY }}/${{ env.IMAGE_NAME }}/auth-api
            ${{ env.DOCKER_REGISTRY }}/${{ secrets.DOCKER_HUB_USERNAME }}/gamecore-auth-api
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: apps/auth-api
          file: apps/auth-api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64

  # Admin API ë¹Œë“œ
  build-admin-api:
    needs: [detect-changes]
    if: needs.detect-changes.outputs.admin-api == 'true' && !failure()
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: "apps/admin-api/package-lock.json"

      - name: Create .npmrc
        working-directory: apps/admin-api
        run: |
          cat > .npmrc << EOF
          @gamecorelabs:registry=https://npm.pkg.github.com
          //npm.pkg.github.com/:_authToken=${{ secrets.GH_TOKEN }}
          EOF

      - name: Create environment file
        working-directory: apps/admin-api
        run: |
          cat > .env.production << EOF
          NODE_ENV=production
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_DATABASE=${{ secrets.DB_DATABASE }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET_NAME=${{ secrets.AWS_S3_BUCKET_NAME }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          HASH_ROUNDS=${{ secrets.HASH_ROUNDS }}
          PORT=3000
          CORS_ORIGIN=https://gamecore.co.kr,https://*.gamecore.co.kr
          EOF

      - name: Install latest @gamecorelabs/nestjs-core
        working-directory: apps/admin-api
        run: npm install @gamecorelabs/nestjs-core@latest

      - name: Install dependencies
        working-directory: apps/admin-api
        run: npm ci

      - name: Build application
        working-directory: apps/admin-api
        run: npm run build:prod

      # - name: Run tests
      #   working-directory: apps/admin-api
      #   run: npm run test --if-present

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GITHUB_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GH_TOKEN }}

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.GITHUB_REGISTRY }}/${{ env.IMAGE_NAME }}/admin-api
            ${{ env.DOCKER_REGISTRY }}/${{ secrets.DOCKER_HUB_USERNAME }}/gamecore-admin-api
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: apps/admin-api
          file: apps/admin-api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64

  # Data API ë¹Œë“œ
  build-data-api:
    needs: [detect-changes]
    if: needs.detect-changes.outputs.data-api == 'true' && !failure()
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: "apps/data-api/package-lock.json"

      - name: Create .npmrc
        working-directory: apps/data-api
        run: |
          cat > .npmrc << EOF
          @gamecorelabs:registry=https://npm.pkg.github.com
          //npm.pkg.github.com/:_authToken=${{ secrets.GH_TOKEN }}
          EOF

      - name: Create environment file
        working-directory: apps/data-api
        run: |
          cat > .env.production << EOF
          NODE_ENV=production
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_DATABASE=${{ secrets.DB_DATABASE }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET_NAME=${{ secrets.AWS_S3_BUCKET_NAME }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          HASH_ROUNDS=${{ secrets.HASH_ROUNDS }}
          PORT=3000
          CORS_ORIGIN=https://gamecore.co.kr,https://*.gamecore.co.kr
          EOF

      - name: Install latest @gamecorelabs/nestjs-core
        working-directory: apps/data-api
        run: npm install @gamecorelabs/nestjs-core@latest

      - name: Install dependencies
        working-directory: apps/data-api
        run: npm ci

      - name: Build application
        working-directory: apps/data-api
        run: npm run build:prod

      # - name: Run tests
      #   working-directory: apps/data-api
      #   run: npm run test --if-present

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GITHUB_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GH_TOKEN }}

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.GITHUB_REGISTRY }}/${{ env.IMAGE_NAME }}/data-api
            ${{ env.DOCKER_REGISTRY }}/${{ secrets.DOCKER_HUB_USERNAME }}/gamecore-data-api
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: apps/data-api
          file: apps/data-api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64

  # í”„ë¡œë•ì…˜ ë°°í¬
  deploy-production:
    needs: [build-frontend, build-auth-api, build-admin-api, build-data-api]
    if: github.ref == 'refs/heads/main' && success()
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://gamecore.co.kr
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create S3 bucket for deployment scripts
        run: |
          # S3 ë²„í‚· ìƒì„± (ì´ë¯¸ ì¡´ì¬í•˜ë©´ ì—ëŸ¬ ë¬´ì‹œ)
          aws s3 mb s3://${{ secrets.DEPLOYMENT_BUCKET }} --region ${{ secrets.AWS_REGION }} || true

      - name: Create deployment script
        run: |
          cat > deploy-script.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "Starting deployment process..."
          echo "Current user: $(whoami)"
          echo "Current directory: $(pwd)"

          # í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ìƒì„±
          sudo mkdir -p /home/ubuntu/gamecore-monorepo
          cd /home/ubuntu/gamecore-monorepo

          # ì†Œìœ ê¶Œ ì„¤ì •
          sudo chown -R ubuntu:ubuntu /home/ubuntu/gamecore-monorepo

          # í•„ìš”í•œ ë””ë ‰í† ë¦¬ ìƒì„±
          mkdir -p letsencrypt traefik

          # Let's Encrypt acme.json íŒŒì¼ ì´ˆê¸°í™” (ê¶Œí•œ ë¬¸ì œ í•´ê²°)
          if [ ! -f letsencrypt/acme.json ]; then
            echo "Creating acme.json file..."
            touch letsencrypt/acme.json
            chmod 600 letsencrypt/acme.json
            echo "acme.json created with proper permissions"
          else
            echo "acme.json already exists"
            chmod 600 letsencrypt/acme.json
          fi

          # acme.json íŒŒì¼ì´ ubuntu ì‚¬ìš©ì ì†Œìœ ì¸ì§€ í™•ì¸
          sudo chown ubuntu:ubuntu letsencrypt/acme.json
          echo "acme.json ownership set to ubuntu:ubuntu"

          # Let's Encrypt ë„ë©”ì¸ ê²€ì¦ì„ ìœ„í•œ ì„ì‹œ ë””ë ‰í† ë¦¬ ìƒì„±
          mkdir -p .well-known/acme-challenge
          chmod 755 .well-known/acme-challenge

          # Traefik ì„¤ì • íŒŒì¼ ìƒì„±
          cat > traefik/traefik.yml << 'TRAEFIK_EOF'
          global:
            checkNewVersion: false
            sendAnonymousUsage: false

          api:
            dashboard: true
            insecure: true

          entryPoints:
            web:
              address: ":80"
              http:
                redirections:
                  entryPoint:
                    to: websecure
                    scheme: https
                    permanent: true

            websecure:
              address: ":443"

          providers:
            docker:
              endpoint: "unix:///var/run/docker.sock"
              exposedByDefault: false

          certificatesResolvers:
            letsencrypt:
              acme:
                email: ${ACME_EMAIL}
                storage: /letsencrypt/acme.json
                keyType: EC256
                httpChallenge:
                  entryPoint: web
                # ê°œë°œ í™˜ê²½ì—ì„œëŠ” stagingì„ ì‚¬ìš©í•´ rate limit ë°©ì§€
                # caServer: https://acme-staging-v02.api.letsencrypt.org/directory

          http:
            middlewares:
              redirect-to-https:
                redirectScheme:
                  scheme: https
                  permanent: true
              secure-headers:
                headers:
                  customRequestHeaders:
                    X-Forwarded-Proto: "https"
                  customResponseHeaders:
                    X-Frame-Options: "SAMEORIGIN"
                    X-Content-Type-Options: "nosniff"
                    X-XSS-Protection: "1; mode=block"
                    Strict-Transport-Security: "max-age=31536000; includeSubDomains"
                    Referrer-Policy: "strict-origin-when-cross-origin"
          TRAEFIK_EOF

          # Docker Hub ë¡œê·¸ì¸
          echo "${DOCKER_HUB_TOKEN}" | docker login -u "${DOCKER_HUB_USERNAME}" --password-stdin

          # ìµœì‹  ì´ë¯¸ì§€ í’€
          docker pull ${DOCKER_HUB_USERNAME}/gamecore-frontend:latest
          docker pull ${DOCKER_HUB_USERNAME}/gamecore-auth-api:latest
          docker pull ${DOCKER_HUB_USERNAME}/gamecore-admin-api:latest
          docker pull ${DOCKER_HUB_USERNAME}/gamecore-data-api:latest

          # í™˜ê²½ ë³€ìˆ˜ íŒŒì¼ ìƒì„±
          cat > .env.production << ENV_EOF
          NODE_ENV=production
          DB_HOST=${DB_HOST}
          DB_PORT=${DB_PORT}
          DB_USERNAME=${DB_USERNAME}
          DB_PASSWORD=${DB_PASSWORD}
          DB_DATABASE=${DB_DATABASE}
          AWS_REGION=${AWS_REGION}
          AWS_S3_BUCKET_NAME=${AWS_S3_BUCKET_NAME}
          AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
          AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
          JWT_SECRET=${JWT_SECRET}
          HASH_ROUNDS=${HASH_ROUNDS}
          ACME_EMAIL=${ACME_EMAIL}
          CORS_ORIGIN=https://gamecore.co.kr,https://*.gamecore.co.kr
          DOCKER_HUB_USERNAME=${DOCKER_HUB_USERNAME}
          ENV_EOF

          # Docker Compose íŒŒì¼ ìƒì„±
          cat > docker-compose.production.yml << 'COMPOSE_EOF'
          version: '3.8'

          services:
            traefik:
              image: traefik:v2.11
              container_name: traefik
              restart: unless-stopped
              command:
                - "--configFile=/etc/traefik/traefik.yml"
              ports:
                - "80:80"
                - "443:443"
                - "8080:8080"
              volumes:
                - /var/run/docker.sock:/var/run/docker.sock:ro
                - ./traefik/traefik.yml:/etc/traefik/traefik.yml:ro
                - ./letsencrypt:/letsencrypt
              networks:
                - gamecore-network
              healthcheck:
                test: ["CMD", "traefik", "healthcheck", "--ping"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 10s

            data-api:
              image: ${DOCKER_HUB_USERNAME}/gamecore-data-api:latest
              restart: unless-stopped
              env_file:
                - .env.production
              depends_on:
                traefik:
                  condition: service_healthy
              networks:
                - gamecore-network
              labels:
                - "traefik.enable=true"
                - 'traefik.http.routers.dataapi.rule=Host(`data-api.gamecore.co.kr`)'
                - "traefik.http.services.dataapi.loadbalancer.server.port=3000"
                - "traefik.http.routers.dataapi.tls.certresolver=letsencrypt"
                - "traefik.http.routers.dataapi.middlewares=secure-headers"
              healthcheck:
                test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 60s

            admin-api:
              image: ${DOCKER_HUB_USERNAME}/gamecore-admin-api:latest
              restart: unless-stopped
              env_file:
                - .env.production
              depends_on:
                traefik:
                  condition: service_healthy
              networks:
                - gamecore-network
              labels:
                - "traefik.enable=true"
                - 'traefik.http.routers.adminapi.rule=Host(`admin-api.gamecore.co.kr`)'
                - "traefik.http.services.adminapi.loadbalancer.server.port=3000"
                - "traefik.http.routers.adminapi.tls.certresolver=letsencrypt"
                - "traefik.http.routers.adminapi.middlewares=secure-headers"
              healthcheck:
                test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 60s

            auth-api:
              image: ${DOCKER_HUB_USERNAME}/gamecore-auth-api:latest
              restart: unless-stopped
              env_file:
                - .env.production
              depends_on:
                traefik:
                  condition: service_healthy
              networks:
                - gamecore-network
              labels:
                - "traefik.enable=true"
                - 'traefik.http.routers.authapi.rule=Host(`auth-api.gamecore.co.kr`)'
                - "traefik.http.services.authapi.loadbalancer.server.port=3000"
                - "traefik.http.routers.authapi.tls.certresolver=letsencrypt"
                - "traefik.http.routers.authapi.middlewares=secure-headers"
              healthcheck:
                test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 60s

            frontend:
              image: ${DOCKER_HUB_USERNAME}/gamecore-frontend:latest
              restart: unless-stopped
              depends_on:
                traefik:
                  condition: service_healthy
                admin-api:
                  condition: service_healthy
                auth-api:
                  condition: service_healthy
                data-api:
                  condition: service_healthy
              networks:
                - gamecore-network
              labels:
                - "traefik.enable=true"
                - 'traefik.http.routers.frontend.rule=Host(`gamecore.co.kr`) || HostRegexp(`{subdomain:[a-z0-9-]+}.gamecore.co.kr`)'
                - "traefik.http.services.frontend.loadbalancer.server.port=3000"
                - "traefik.http.routers.frontend.tls.certresolver=letsencrypt"
                - "traefik.http.routers.frontend.middlewares=secure-headers"
              healthcheck:
                test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 60s

          networks:
            gamecore-network:
              driver: bridge
              ipam:
                config:
                  - subnet: 172.20.0.0/16
          COMPOSE_EOF

          echo "Docker Compose file created"

          # ê¸°ì¡´ ì»¨í…Œì´ë„ˆ ì •ë¦¬
          echo "Stopping existing containers..."
          docker-compose -f docker-compose.production.yml down || true

          # ìƒˆ ì»¨í…Œì´ë„ˆ ì‹œì‘
          echo "Starting services..."
          docker-compose -f docker-compose.production.yml up -d

          # ì„œë¹„ìŠ¤ ì‹œì‘ ëŒ€ê¸° (SSL ì¸ì¦ì„œ ë°œê¸‰ ì‹œê°„ ê³ ë ¤)
          echo "Waiting for services to start and SSL certificates to be issued..."

          # ë‹¨ê³„ì  ì„œë¹„ìŠ¤ ì‹œì‘ í™•ì¸
          echo "Checking Traefik startup..."
          for i in {1..30}; do
            if docker-compose -f docker-compose.production.yml ps traefik | grep -q "healthy"; then
              echo "âœ… Traefik is healthy"
              break
            fi
            echo "â³ Waiting for Traefik to be ready... ($i/30)"
            sleep 10
          done

          echo "Checking API services startup..."
          for i in {1..60}; do
            if docker-compose -f docker-compose.production.yml ps | grep -E "(data-api|admin-api|auth-api)" | grep -q "healthy"; then
              echo "âœ… API services are starting to become healthy"
              break
            fi
            echo "â³ Waiting for API services to be ready... ($i/60)"
            sleep 10
          done

          # ì¶”ê°€ ëŒ€ê¸° ì‹œê°„ (SSL ì¸ì¦ì„œ ë°œê¸‰)
          echo "Waiting additional time for SSL certificate generation..."
          sleep 180

          # ì»¨í…Œì´ë„ˆ ìƒíƒœ í™•ì¸
          echo "Checking container status..."
          docker-compose -f docker-compose.production.yml ps

          # Traefik ë¡œê·¸ í™•ì¸ (SSL ì¸ì¦ì„œ ë°œê¸‰ í™•ì¸)
          echo "Checking Traefik logs for SSL certificate generation..."
          docker-compose -f docker-compose.production.yml logs traefik | tail -100

          # acme.json ìƒíƒœ í™•ì¸
          echo "Checking acme.json status..."
          if [ -f letsencrypt/acme.json ]; then
            echo "acme.json file exists"
            echo "File size: $(stat -c%s letsencrypt/acme.json) bytes"
            echo "File permissions: $(stat -c%a letsencrypt/acme.json)"
            if [ -s letsencrypt/acme.json ]; then
              echo "âœ… acme.json contains certificate data"
            else
              echo "âš ï¸ acme.json is empty - certificates may still be generating"
            fi
          else
            echo "âŒ acme.json file not found"
          fi

          # í—¬ìŠ¤ì²´í¬ (HTTPì™€ HTTPS ëª¨ë‘ í™•ì¸)
          echo "Performing health checks..."

          # ë¨¼ì € HTTP í—¬ìŠ¤ì²´í¬ (SSL ì¸ì¦ì„œ ë°œê¸‰ ì „ì—ë„ ë™ì‘í•´ì•¼ í•¨)
          echo "Testing HTTP endpoints first..."
          for i in {1..30}; do
            echo "HTTP Health check attempt $i/30..."
            
            if curl -f --max-time 10 --connect-timeout 5 http://gamecore.co.kr/health >/dev/null 2>&1; then
              echo "âœ… HTTP gamecore.co.kr health check passed"
              break
            fi
            
            echo "â³ Waiting for HTTP services to be ready..."
            sleep 10
          done

          # SSL ì¸ì¦ì„œ ë°œê¸‰ í™•ì¸ í›„ HTTPS í…ŒìŠ¤íŠ¸
          echo "Testing HTTPS endpoints..."
          for i in {1..20}; do
            echo "HTTPS Health check attempt $i/20..."
            
            if curl -f --max-time 10 --connect-timeout 5 -k https://gamecore.co.kr/health >/dev/null 2>&1; then
              echo "âœ… HTTPS gamecore.co.kr health check passed"
              break
            fi
            
            echo "â³ Waiting for HTTPS services to be ready..."
            sleep 15
          done

          echo "Deployment completed successfully!"

          # ë¯¸ì‚¬ìš© ì´ë¯¸ì§€ ì •ë¦¬
          docker image prune -f
          docker system prune -f --volumes

          echo "Cleanup completed!"
          EOF

          chmod +x deploy-script.sh

      - name: Upload deployment script to S3
        run: |
          aws s3 cp deploy-script.sh s3://${{ secrets.DEPLOYMENT_BUCKET }}/deploy-script.sh
          echo "Deployment script uploaded to S3"

      - name: Check EC2 instance status
        run: |
          INSTANCE_STATUS=$(aws ec2 describe-instance-status \
            --instance-ids ${{ secrets.INSTANCE_ID }} \
            --query 'InstanceStatuses[0].InstanceStatus.Status' \
            --output text)

          if [ "$INSTANCE_STATUS" != "ok" ]; then
            echo "Instance is not in OK status: $INSTANCE_STATUS"
            exit 1
          fi

          echo "Instance status: $INSTANCE_STATUS"

      - name: Execute deployment via SSM
        run: |
          echo "Sending command to EC2 instance..."

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ secrets.INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters commands='[
              "export DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }}",
              "export DOCKER_HUB_TOKEN=${{ secrets.DOCKER_HUB_TOKEN }}",
              "export DB_HOST=${{ secrets.DB_HOST }}",
              "export DB_PORT=${{ secrets.DB_PORT }}",
              "export DB_USERNAME=${{ secrets.DB_USERNAME }}",
              "export DB_PASSWORD=${{ secrets.DB_PASSWORD }}",
              "export DB_DATABASE=${{ secrets.DB_DATABASE }}",
              "export AWS_REGION=${{ secrets.AWS_REGION }}",
              "export AWS_S3_BUCKET_NAME=${{ secrets.AWS_S3_BUCKET_NAME }}",
              "export AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}",
              "export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}",
              "export JWT_SECRET=${{ secrets.JWT_SECRET }}",
              "export HASH_ROUNDS=${{ secrets.HASH_ROUNDS }}",
              "export ACME_EMAIL=${{ secrets.ACME_EMAIL }}",
              "cd /tmp",
              "aws s3 cp s3://${{ secrets.DEPLOYMENT_BUCKET }}/deploy-script.sh ./deploy-script.sh",
              "chmod +x deploy-script.sh",
              "./deploy-script.sh"
            ]' \
            --timeout-seconds 1800 \
            --query 'Command.CommandId' \
            --output text)

          echo "Command ID: $COMMAND_ID"
          echo "COMMAND_ID=$COMMAND_ID" >> $GITHUB_ENV

      - name: Wait for deployment completion
        run: |
          echo "Waiting for command execution to complete..."

          # ìµœëŒ€ 30ë¶„ ëŒ€ê¸°
          timeout 1800 bash -c '
            while true; do
              STATUS=$(aws ssm get-command-invocation \
                --command-id ${{ env.COMMAND_ID }} \
                --instance-id ${{ secrets.INSTANCE_ID }} \
                --query "Status" \
                --output text 2>/dev/null)
              
              echo "Command status: $STATUS"
              
              if [ "$STATUS" = "Success" ]; then
                echo "Command completed successfully"
                break
              elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
                echo "Command failed with status: $STATUS"
                exit 1
              fi
              
              sleep 30
            done
          '

      - name: Get deployment results
        if: always()
        run: |
          echo "Getting command execution results..."

          # ëª…ë ¹ ì‹¤í–‰ ê²°ê³¼ ê°€ì ¸ì˜¤ê¸°
          aws ssm get-command-invocation \
            --command-id ${{ env.COMMAND_ID }} \
            --instance-id ${{ secrets.INSTANCE_ID }} \
            --query "StandardOutputContent" \
            --output text > deployment_output.log

          # í‘œì¤€ ì¶œë ¥ ë‚´ìš© í‘œì‹œ
          echo "=== Deployment Output ==="
          cat deployment_output.log

          # ì—ëŸ¬ ì¶œë ¥ í™•ì¸
          ERROR_OUTPUT=$(aws ssm get-command-invocation \
            --command-id ${{ env.COMMAND_ID }} \
            --instance-id ${{ secrets.INSTANCE_ID }} \
            --query "StandardErrorContent" \
            --output text)

          if [ -n "$ERROR_OUTPUT" ] && [ "$ERROR_OUTPUT" != "None" ]; then
            echo "=== Error Output ==="
            echo "$ERROR_OUTPUT"
          fi

          # ëª…ë ¹ ìƒíƒœ ì •ë³´ í™•ì¸
          echo "=== Command Status Details ==="
          aws ssm get-command-invocation \
            --command-id ${{ env.COMMAND_ID }} \
            --instance-id ${{ secrets.INSTANCE_ID }} \
            --query '[Status,StatusDetails,ExecutionStartDateTime,ExecutionEndDateTime,ResponseCode]' \
            --output table

          # ìµœì¢… ìƒíƒœê°€ Failedì¸ ê²½ìš° ì‹¤íŒ¨ ì²˜ë¦¬
          FINAL_STATUS=$(aws ssm get-command-invocation \
            --command-id ${{ env.COMMAND_ID }} \
            --instance-id ${{ secrets.INSTANCE_ID }} \
            --query "Status" \
            --output text)

          if [ "$FINAL_STATUS" = "Failed" ]; then
            echo "âŒ Deployment failed"
            exit 1
          fi

      - name: Cleanup S3 deployment script
        if: always()
        run: |
          aws s3 rm s3://${{ secrets.DEPLOYMENT_BUCKET }}/deploy-script.sh || true

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."

          # ê° ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸
          services=("https://gamecore.co.kr/health" "https://auth-api.gamecore.co.kr/health" "https://admin-api.gamecore.co.kr/health" "https://data-api.gamecore.co.kr/health")

          for service in "${services[@]}"; do
            echo "Checking $service..."
            if curl -f --retry 3 --retry-delay 5 --max-time 10 "$service" >/dev/null 2>&1; then
              echo "âœ… $service is healthy"
            else
              echo "âŒ $service is not responding"
              exit 1
            fi
          done

      - name: Notify deployment success
        if: success()
        run: |
          echo "ğŸ‰ Deployment to production completed successfully!"
          echo "ğŸ”— Frontend: https://gamecore.co.kr"
          echo "ğŸ”— Auth API: https://auth-api.gamecore.co.kr"
          echo "ğŸ”— Admin API: https://admin-api.gamecore.co.kr"
          echo "ğŸ”— Data API: https://data-api.gamecore.co.kr"
          echo "ğŸ“Š Deployed via AWS Systems Manager"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "âŒ Deployment to production failed!"
          echo "Command ID: ${{ env.COMMAND_ID }}"
          echo "Please check the SSM command execution logs in AWS Console"
          echo "Instance ID: ${{ secrets.INSTANCE_ID }}"
